user  root;
worker_processes  1;
# daemon off;
# worker_cpu_affinity auto;
# error_log  logs/error.log;
# error_log  logs/error.log  notice;
# error_log  logs/error.log  info;

# load_module modules/ngx_http_qatzip_filter_module.so;
worker_rlimit_nofile 1000000;
master_process on;

events {
    use epoll;
    worker_connections  102400; #This directive tells how many connections a worker_process can have.  Ensure to never set this too low or high. To low will prevent getting good performance, and too high may CPU starve connections.
    multi_accept on;  #This directive allows worker_processes to handle multiple connections at a time rather than dealing with only one at a time.
    accept_mutex off;  #This directive tells the worker_processes to get in a line rather than all rush for a new connection.
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    access_log      off;
    sendfile        on;
    sendfile_max_chunk 512k;
    tcp_nopush      on;

    open_file_cache max=10240000 inactive=60s;
    open_file_cache_valid 80s;
    open_file_cache_min_uses 1;

    keepalive_timeout  10000s;
    keepalive_requests 1000000;
    # gzip_http_version   1.0;

    # zstd on;
    # zstd_min_length 256; # no less than 256 bytes
    # zstd_comp_level 1; # set the level to 3

    # qatzip_sw no;
    # qatzip_min_length 128;
    # qatzip_buffers 16 8k;
    # qatzip_chunk_size   64k;
    # qatzip_stream_size  256k;
    # qatzip_sw_threshold 256;
    # qatzip_comp_level   1;
    # qatzip_polling_mode busy;

    # gzip on;
    # gzip_min_length     128;
    # gzip_comp_level     1;
    # gzip_vary            on;
    # gzip_disable        "msie6";


    server {
        listen       8081 reuseport backlog=131072 so_keepalive=on; # Reuseport will provide the kernel behavior of load balancing incoming connections to the available NGINX socket listeners. There is an NGINX socket listener per server block, the block we are currently in,now. The backlog parameter tells NGINX how many connections can be in a wait queue when it cannot service the connection immeditatly.
        sendfile on;    # Though already provided in a parent block, continue to specify it.

        keepalive_requests 1000000;
        keepalive_timeout 10000s; # Even though TCP keepalives are disabled, we still set it to a value of 0

        tcp_nopush on;  # This directive tells NGINX to wait to send data once it has a payload the size of MSS
        tcp_nodelay on; # This works opposite of tcp_nopush, where here we do not delay when sending data. We set this to ensure packets get sent without delaying  for some perious of time. This is to reduce latency.
        lingering_close off; # We immediatly close the TCP connection without waiting.
        lingering_time 1; # We still set this even though we disabled lingering delay.
        server_name localhost; # Name of the server.

        location / {
            root   html;
            index  index.html;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}